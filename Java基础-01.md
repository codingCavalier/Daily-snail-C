#### 1、Java如何实现的跨平台？
在不同操作系统上实现各自对应的JVM虚拟机（相同的接口，调用平台底层的能力），把Java代码编译成字节码文件，然后在JVM虚拟机上运行，而不是直接在具体的某个操作系统上运行，避免针对不同操作系统开发一套相同功能的代码，降低开发成本和维护成本。

#### 2、JDK和JRE的区别？
JDK是java develop kits，是java开发工具包，包含了JRE和开发工具（javac等）。JRE是java runtime environment，是java运行时环境（JVM和必须的类库），有了JRE就可以运行java程序了。

#### 3、为什么需要配置Java环境变量？
因为Java程序是一种可以跨平台运行的程序，而它的跨平台实现靠的是独立的Java运行环境，为了让系统在运行Java程序时找到这个运行环境，就需要通过配置path的方式告诉系统，运行环境在哪个位置。

#### 4、Java语言的特性？
1、面向对象：这是一种编程思想，编程理念，指导程序开发者如何去组织程序架构，开发出更简洁更易于维护且更好拓展的程序，利用封装，继承，多态的基本思想，进行程序设计。<br>
2、内存回收：Java提供了自动的内存回收机制（堆内存，新生代，老年代，永久代（Java8移除改为元数据空间使用本地内存存储class等元数据），标记清除算法，内存泄漏，内存溢出）。<br>
3、异常处理：Java在保障程序健壮性方面提供了异常处理机制（try、catch、throw抛出单个异常时使用、finally、throws用在方法上表明这个方法会抛出1个或多个异常）。<br>
4、多线程编程：<br>
5、发射机制：<br>

#### 5、==和equals的区别？
1、==是操作符，用于比较两个变量的值，如果是基本数据类型，比较的是数值大小，如果是引用数据类型，比较的是内存地址。<br>
2、equals是Object类的一个方法，允许子类重写，作用是比较两个对象的内容是否相等，默认情况下比较的是内存地址，我们可以重写这个方法，自定义内容比较的具体逻辑。<br>
3、Java虚拟机内存中会默认存储-128~127里的Integer对象，所以在进行==比较时，前面128个对象是返回true的。<br>
4、==两边有一个是数值类型的，那么会自动拆箱，以数值类型进行比较。<br>
5、拆箱是Integer.intValue，装箱是Integer.valueOf <br>
6、对于包装类型，equals方法不会进行类型转换 <br>
```Java
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);//true
        System.out.println(e==f);//false 超出了128个预加载对象
        System.out.println(c==(a+b));//true 拆箱对比
        System.out.println(c.equals(a+b));//true 装箱对比
        System.out.println(g==(a+b));//true 拆箱
        System.out.println(g.equals(a+b));//false 装箱，类型不一样
        System.out.println(g.equals(a+h));//true a+h自动装箱Long类型
    }
}
```

#### 6、Java中有哪些数学函数？
位于java.lang.Math中，有：<br>
基本数学函数：abs绝对值、max、min。<br>
指数函数：exp(a)求e的a次方、log、pow(a,b)求a的b次方、sqrt求平方根、cbrt求立方根。<br>
三角函数：sin、cos、tan、asin、acos、atan、toRadians角度转弧度、toDegrees弧度转角度。<br>
双曲函数：sinh、cosh、tanh、asinh、acosh、atanh。<br>
其他函数：random随机数、round舍入函数。<br>

#### 7、Java中的运算符？
&与运算，两个都是1，才为1。<br>
|或运算，两个有一个为1，就为1。<br>
~非运算，即位取反，1为0，0为1。<br>
^异或运算，两个操作数的位中，相同则结果为0，不同则结果为1。<br>
<<有符号左移运算，例如5<<35等同于左移3位，因为int一共32位，5左移3位就是5乘以2的3次方，等于40。<br>
>>有符号右移运算，例如16>>3，就是16除以2的3次方，等于2。15>>3，就是15除以8，得到的整数商，等于1。（这里假如是单数，那么结果是除完以后的整数商）<br>
>>>无符号右移，同右移，但是结果全变正数。<br>
没有<<<这个符号！！！<br>
计算机内，都是使用的补码进行计算，原码就是原码，反码是原码按位取反，补码是反码+1得到的，如果计算完了是负数，那么需要从补码反向计算回原码，再转10进制得到结果。如果计算完了是正数，那么直接转10进制就是结果，因为正数的原码反码补码是一样的。<br>
计算补码的方式为反码+1，用一句话概括就是：保证符号位不变，其余位置取反加1（从右往左遇到第一个1，然后剩下的全部取反就是了），-10的原码1....0000 1010，反码1....1111 0101，补码1....1111 0110，看上去就是原码符号位不变，从右到左遇到第一个1的位都不变，其余全部取反，这是快速写补码的方法<br>
对负数右移以后，高位补1，然后反向运算出原码（-1再取反，或者取反再+1，两种方式都可以，好比-（3-1）和（-3+1）是一样的），转10进制，得到结果<br>

#### 8、Java中运算符的优先级？
```
()：括号运算符，具有最高优先级；
!、~、++、–：逻辑非、位取反、自增、自减运算符；
*、/、%：乘、除、取模运算符，优先级相同，从左向右结合；
+、-：加、减运算符，优先级相同，从左向右结合；
<<、>>、>>>：左移、右移、无符号右移运算符，优先级相同，从左向右结合；
<、<=、>、>=：小于、小于等于、大于、大于等于运算符，优先级相同，从左向右结合；
==、!=：等于、不等于运算符，优先级相同，从左向右结合；
&：按位与运算符，优先级较低；
^：按位异或运算符，优先级更低；
|：按位或运算符，优先级最低；
&&：逻辑与运算符，优先级较低；
||：逻辑或运算符，优先级更低；
?:：三元运算符，优先级最低；
```

#### 9、final的作用？
1、修饰引用，如果是基本数据类型，那么就是常量，不可改变。如果是引用数据类型，则对象的地址不可改变，但是对象内的数据可以改变。如果是类的成员变量，则必须直接赋值。<br>
2、修饰方法，则方法无法被重写，但是可以被继承（即子类可以使用）。<br>
3、修饰类，则类无法被继承。<br>

#### 10、final修饰一个类的成员变量时，是引用不能变（=号左侧），还是引用的对象不能变（=号右侧）？
引用不能变，即此引用指向了一个固定的地址，但是被指向的对象不一定不能变，比如集合、数组、自定义类。

#### 11、this和super关键字的作用？
this是对象内部指代自身的引用，可以通过this调用成员变量，成员方法。当成员变量和局部变量存在同名问题时，可以用this引用来区分。<br>
super指代父类，可以通过super调用父类的成员变量，成员方法，构造函数。<br>

#### 12、为什么不允许类的静态方法使用类的非静态变量？
静态方法属于类本身，在类加载时也同步加载到内存中。而非静态变量属于类的实例对象，当类加载时，还没有类的实例对象，也就没有非静态变量，无法使用它。

#### 13、final和static的区别？
都可以修饰成员变量，成员方法。final还可以修饰类，表示不可被继承。static修饰的东西表示它属于这个类，而非类的实例，在类被加载时一并加载到内存，主要用于初始化等场景。

#### 14、int可以强转成byte吗？
可以，高24位丢失。

#### 15、char可以存储一个汉字吗？
Java默认采用Unicode编码，默认编码规则采用UTF-16(编码规则才是能否存储的关键，Character类的注释中有写是UTF-16，而且采用的是BE大端)，占2个字节，而char正好可以存储2个字节的数据，所以可以存储一个汉字。（可以看这个链接：https://blog.csdn.net/caoruntao_/article/details/108668319）<br>
UTF-16用两个字节表示一个字符，那么用两个字节表示必然存在字节序的问题(Byte Order Mark(BOM))，即大小端的问题。UTF-16根据BOM分为UTF-16BE(最低地址存放高位字节，编码前会放置FEFF)和UTF-16LE(最高地址存放高位字节，编码前会放置FFFE)

#### 16、byte类型127+1等于多少？
存储范围是-128 ~ 127，+1后会溢出，127的补码为0111 1111，+1后得到1000 0000，负数的补码转十进制：对各位取反0111 1111，转十进制127，加上负号-127，再减1，得到-128。

#### 17、为什么数组的起始索引是0不是1？
这个习惯来源于机器语言，那时要计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。将起始索引设为1要么浪费数组的第一个元素的空间，要么会花费额外的时间来将索引减1。

#### 18、Java中的基本数据类型和所占字节？
byte 8位1个字节，short 16位2个字节，int 32位4个字节，long 64位8个字节，char 16位2个字节，float 32位4个字节，double 64位8个字节

#### 19、Java中的数据类型提升？
为了保证计算的精确性，java在运算时会自动将低精度类型的数据向高精度类型转换，比如int和double相加，int会被转成double类型，再计算

#### 20、机器数、真值、原码、反码、补码
机器数：<br>
一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。<br>
比如：十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 1000 0011 。那么，这里的 0000 0011 和 1000 0011 就是机器数。<br>
真值：<br>
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3 而不是形式值131（ 1000 0011 转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。<br>
比如：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1<br>
原码：<br>
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：<br>
[+1]原 = 0000 0001 <br>
[-1]原 = 1000 0001 <br>
第一位是符号位。因为第一位是符号位，所以8位二进制数的取值范围就是：[1111 1111 , 0111 1111]，即[-127 , 127]。原码是人脑最容易理解和计算的表示方式。<br>
反码：<br>
反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。<br>
[+1] = [00000001]原 = [00000001]反 <br>
[-1] = [10000001]原 = [11111110]反 <br>
可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。<br>
补码：<br>
补码的表示方法是：正数的补码就是其本身。负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)<br>
[+1] = [00000001]原 = [00000001]反 = [00000001]补 <br>
[-1] = [10000001]原 = [11111110]反 = [11111111]补 <br>
对于负数，补码的表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。<br>
原因：<br>
因为[0000 0000]补、[1000 0000]补都表示0，一个+0，一个-0，显然这有些浪费，故将-0的补码，对应的真值设计成-128，-128是没有原码和反码的。这就是为什么8位二进制，使用原码或反码表示的范围为[-127 , +127]，而使用补码表示的范围为[-128 , 127]。<br>
int表示的取值范围就是[-2的31次方 , 2的31次方 - 1]<br>
原链接：https://cloud.tencent.com/developer/article/2038347<br>

#### 21、Object类常用方法？
clone浅复制需要实现Cloneable接口才可以调用、getClass、toString、finalize、equals、hashCode、wait、notify、notifyAll

#### 22、equals的特性？
java语言规范要求equals方法具有下面的特性：<br>

自反性：对于任何非空引用x, x.equals(x)应该返回true;<br>
对称性：对于任何引用x和y, 有y.equals(x)返回true,x.equals(y)也应该返回true;<br>
传递性：对于任何引用x,y,z, 如果x.equals(y)返回true, y.equals(z)返回true, 那么x.equals(z)也应该返回true;<br>
一致性：如果x,y引用的对象没有发生变化, 反复调用x.equals(y)应该返回同样的结果;<br>
对于任意非空引用x, x.equals(null)返回false;<br>

#### 23、关于hashCode方法？
该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。hashCode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。<br>
当集合需要添加新的对象时，先调用这个对象的hashCode()方法，得到对应的hash值，实际上hashmap中会有一个table保存已经存进去的对象的hash值，如果table中没有该hash值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。<br>

#### 24、equals和hashCode的关系？
如果equals为true，hashCode一定相等；如果equals为false，hashCode也可能相等；如果hashCode值不等，equals一定不等；重写equals方法时，一定要重写hashCode方法。<br>
hashCode像是人的名字，而equals则是人的本身，本身相等说明是同一个人，那名字一定相等。但是名字一样，不一定是同一个人。

#### 25、String str = "i" 与 String str = new String("i") 一样吗？
不一样，前者引用直接指向常量池中的"i"，后者指向的是堆内存中的一个对象，再由这个对象指向常量池中的"i"。

#### 26、String s = "123"; s = s + "456"; 这两行代码执行后，原始的 String 对象中的内容到底变了没有？
没有变，Java中String中的内容是不可变的，+号是产生了一个新的字符串对象，并将s指向这个新对象的引用。

#### 27、如何将字符串反转？
使用 StringBuilder 的 reverse() 方法

#### 28、String类常用方法？
length、charAt、indexOf、substring、contains、startsWith、endWith、isEmpty、getBytes、toCharArray、concat、toLowerCase、toUpperCase、replace、trim、

#### 29、String s = new String("123"); 创建了几个字符串对象？
第一次调用，产生两个对象，堆内存一个，字符串常量池一个。第二次调用，只会在堆内存产生一个对象。

#### 30、想新建一个java.lang.String类，能建成功吗？这个类会被类加载器加载吗？为什么？
不能成功新建一个名为java.lang.String的类，这个类也不会被类加载器加载，因为这样做违反了Java的命名规范和类加载机制。

#### 31、String类可以被继承吗？
不可以，final的。

#### 32、String，Stringbuffer，StringBuilder 的区别？
String不可修改，其他两个可以修改。String和StringBuffer都是线程安全的，StringBuilder不是线程安全的。性能方面，StringBuilder最快，其次StringBuffer，最后String，因为它很大概率要创建新对象。String存储在常量池中，其他存储在堆内存中。

#### 33、"+" 连接符的效率为何低？
JVM会隐式创建StringBuilder，在循环里，使用+会导致创建大量对象，建议在循环外显示创建StringBuilder对象。还有一种特殊情况，如果"+"拼接的是常量池中的字符串时，编译器会进行优化，直接将两个字符串常量拼接好。<br>
所以"+"连接符对于直接相加的字符串常量效率很高，因为在编译期间便确定了它的值；但对于间接相加的情况效率就会变低，建议单线程时使用StringBuilder，多线程时使用StringBuffer替代。

#### 34、说说缓冲区数据结构bytebuffer？
缓冲区是由具有相同类型的数值构成的数组，Buffer是一个抽象类，它有很多子类，包括ByteBuffer、CharBuffer、DoubleBuffer、IntBuffer、LongBuffer、ShortBuffer。<br>
每个缓冲区都具有4个属性：容量capacity、下一次要读写的位置position、读取界限limit（容量1024，但是界限是512，则512后的数据都不可读写，那么缓冲区的实际使用大小是512）、标记mark<br>
标记，一个备忘位置。保存某个时刻的position指针的值，通过调用mark()实现，当mark被置为负值时，表示废弃标记。标记在设定前是未定义的(undefined)。使用场景是，假设缓冲区中有 10 个元素（0-9），position 目前的位置为 2(也就是如果get的话是第三个元素)，现在只想发送 6 - 10 之间的缓冲数据，此时我们可以 buffer.mark(buffer.position())；即把当前的 position 记入 mark 中，然后 buffer.position(6)；此时发送给 channel 的数据就是 6 - 10 的数据。发送完后，我们可以调用 buffer.reset() 使得 position = mark，因此这里的 mark 只是用于临时记录一下位置用的。<br>

使用缓冲区的主要目的是执行读写循环操作。Buffer及其子类都不是线程安全的。<br>
假设我们有一个缓冲区，在一开始，它的位置是0，界限等于容量。我们不断地调用put将值添加到这个缓冲区中，当我们耗尽所有的数据或者写入的数据量达到容量大小时，就该切入到读操作了。<br>
这时可以调用flip方法将界限设置到当前位置，并把指针位置复位到0。现在在remaining方法返回正数时（它返回的值是界限 - 指针位置），不断地调用get。在我们将缓冲区中所有的值都读完后，调用clear使缓冲区为下一次写循环做好准备。clear方法将指针位置复位到0，并将界限复位到容量。<br>
如果想重读缓冲区，可以使用 rewind 或 mark/reset 进行复位。然后可以 用某个通道的数据填充缓冲区，或者将缓冲区的内容写出到通道中。<br>

```Java
ByteBuffer buffer = ByteBuffer.allocate(RECORD_SIZE);
channel.read(buffer); // 将通道里的数据，写入buffer
channel.position(newpos);
buffer.flip(); // 进入读模式
channel.write(buffer); // 将buffer里的数据读进通道
```

#### 35、Java 创建对象有几种方式？
new（构造函数）、反射、clone、序列化反序列化。这三种应该是模式，而不是创建对象的本质：依赖注入、工厂模式、Builder构建器模式

#### 36、说说对象创建的过程？
1\当虚拟机执行到 new 关键字时，首先会去运行时常量池中查找该引用所指向的类有没有被虚拟机加载，如果没有被加载，那么会进行类的加载过程，如果已经被加载，那么进行下一步。<br>
2\当类元信息被加载之后，我们就可以从常量池找到对应的类元信息，通过类元信息来确定类型和后面需要申请的内存大小。<br>
3\对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。（分配完内存后，需要对对象的字段进行零值初始化，对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值，这也就解释了为什么这些字段在不需要进程初始化时候就能直接使用）<br>
4\分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashCode，GC分代年龄等信息<br>
5\然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。执行对象的构造方法，这里做的操作才是程序员真正想做的操作，例如初始化其他对象啊等等操作，至此，对象创建成功。<br>
原链接：https://zhuanlan.zhihu.com/p/143743569 <br>
JVM先查找class文件，加载class到内存，创建class对象（初始化静态常量和加载静态方法），堆内存分配空间，创建对象并给成员变量赋0值，执行所有初始化操作（成员变量赋值等），执行构造器

#### 37、构造函数，构造代码块（非静态代码块），静态代码块执行顺序？
静态代码块先执行，因为类一加载，就执行了，用于在类的层级上进行一些初始化操作，即给类做初始化。（它的执行优先于主函数即main方法）<br>
其次是构造代码块，也就是非静态代码块，创建每个对象时，不管调用哪个构造函数，都会先调用构造代码块，用于在实例对象的层级上进行统一的初始化操作，即给所有该类的对象们做初始化<br>
最后是构造函数，用于给具体某个实例对象做初始化操作。<br>

先父再子，先静再动，先变量，再代码块，再构造，即：（父类静态变量、父类静态代码块），（子类静态变量、子类静态代码块），父类变量，父类代码块，父类构造函数，子类变量，子类代码块，子类构造函数<br>
