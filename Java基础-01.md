#### 1、Java如何实现的跨平台？
在不同操作系统上实现各自对应的JVM虚拟机（相同的接口，调用平台底层的能力），把Java代码编译成字节码文件，然后在JVM虚拟机上运行，而不是直接在具体的某个操作系统上运行，避免针对不同操作系统开发一套相同功能的代码，降低开发成本和维护成本。

#### 2、JDK和JRE的区别？
JDK是java develop kits，是java开发工具包，包含了JRE和开发工具（javac等）。JRE是java runtime environment，是java运行时环境（JVM和必须的类库），有了JRE就可以运行java程序了。

#### 3、为什么需要配置Java环境变量？
因为Java程序是一种可以跨平台运行的程序，而它的跨平台实现靠的是独立的Java运行环境，为了让系统在运行Java程序时找到这个运行环境，就需要通过配置path的方式告诉系统，运行环境在哪个位置。

#### 4、Java语言的特性？
1、面向对象：这是一种编程思想，编程理念，指导程序开发者如何去组织程序架构，开发出更简洁更易于维护且更好拓展的程序，利用封装，继承，多态的基本思想，进行程序设计。<br>
2、内存回收：Java提供了自动的内存回收机制（堆内存，新生代，老年代，永久代（Java8移除改为元数据空间使用本地内存存储class等元数据），标记清除算法，内存泄漏，内存溢出）。<br>
3、异常处理：Java在保障程序健壮性方面提供了异常处理机制（try、catch、throw抛出单个异常时使用、finally、throws用在方法上表明这个方法会抛出1个或多个异常）。<br>
4、多线程编程：<br>
5、反射机制：<br>

#### 5、==和equals的区别？
1、==是操作符，用于比较两个变量的值，如果是基本数据类型，比较的是数值大小，如果是引用数据类型，比较的是内存地址。<br>
2、equals是Object类的一个方法，允许子类重写，作用是比较两个对象的内容是否相等，默认情况下比较的是内存地址，我们可以重写这个方法，自定义内容比较的具体逻辑。<br>
3、Java虚拟机内存中会默认存储-128~127里的Integer对象，所以在进行==比较时，这256个对象是返回true的。<br>
4、==两边有一个是数值类型的，那么会自动拆箱，以数值类型进行比较。（拆箱是Integer.intValue，装箱是Integer.valueOf）<br>
5、对于包装类型，equals方法不会进行类型转换，所以两侧必须是相同的包装类型才能继续比较，否则就是false。<br>
```Java
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);//true
        System.out.println(e==f);//false 不属于256个预加载对象
        System.out.println(c==(a+b));//true 拆箱对比
        System.out.println(c.equals(a+b));//true 装箱对比
        System.out.println(g==(a+b));//true 拆箱
        System.out.println(g.equals(a+b));//false 装箱，类型不一样
        System.out.println(g.equals(a+h));//true a+h自动装箱Long类型
    }
}
```

#### 6、Java中有哪些数学函数？
位于java.lang.Math中，有：<br>
基本数学函数：abs绝对值、max、min。<br>
指数函数：exp(a)求e的a次方、log、pow(a,b)求a的b次方、sqrt求平方根、cbrt求立方根。<br>
三角函数：sin、cos、tan、asin、acos、atan、toRadians角度转弧度、toDegrees弧度转角度。<br>
双曲函数：sinh、cosh、tanh、asinh、acosh、atanh。<br>
其他函数：random随机数、round舍入函数。<br>

#### 7、Java中的运算符？
```
&与运算，两个都是1，才为1。<br>
|或运算，两个有一个为1，就为1。<br>
~非运算，即位取反，1为0，0为1。<br>
^异或运算，两个操作数的位中，相同则结果为0，不同则结果为1。<br>
<<有符号左移运算，例如5<<35等同于左移3位，因为int一共32位，5左移3位就是5乘以2的3次方，等于40。<br>
>>有符号右移运算，例如16>>3，就是16除以2的3次方，等于2。15>>3，就是15除以8，得到的整数商，等于1。（这里假如是单数，那么结果是除完以后的整数商）<br>
>>>无符号右移，同右移，但是结果全变正数。<br>
没有<<<这个符号！！！<br>
```
计算机内，都是使用的补码进行计算，原码就是原码，反码是原码按位取反，补码是反码+1得到的，如果计算完了是负数，那么需要从补码反向计算回原码，再转10进制得到结果。如果计算完了是正数，那么直接转10进制就是结果，因为正数的原码反码补码是一样的。<br>
计算补码的方式为反码+1，用一句话概括就是：保证符号位不变，其余位置取反加1（从右往左遇到第一个1，然后剩下的全部取反就是了），-10的原码1....0000 1010，反码1....1111 0101，补码1....1111 0110，看上去就是原码符号位不变，从右到左遇到第一个1的位都不变，其余全部取反，这是快速写补码的方法<br>
对负数右移以后，高位补1，然后反向运算出原码（-1再取反，或者取反再+1，两种方式都可以，好比-（3-1）和（-3+1）是一样的），转10进制，得到结果<br>

#### 8、Java中运算符的优先级？
```
()：括号运算符，具有最高优先级；
!、~、++、–：逻辑非、位取反、自增、自减运算符；
*、/、%：乘、除、取模运算符，优先级相同，从左向右结合；
+、-：加、减运算符，优先级相同，从左向右结合；
<<、>>、>>>：左移、右移、无符号右移运算符，优先级相同，从左向右结合；
<、<=、>、>=：小于、小于等于、大于、大于等于运算符，优先级相同，从左向右结合；
==、!=：等于、不等于运算符，优先级相同，从左向右结合；
&：按位与运算符，优先级较低；
^：按位异或运算符，优先级更低；
|：按位或运算符，优先级最低；
&&：逻辑与运算符，优先级较低；
||：逻辑或运算符，优先级更低；
?:：三元运算符，优先级最低；
```

#### 9、final的作用？
1、修饰引用，如果是基本数据类型，那么就是常量，不可改变。如果是引用数据类型，则对象的地址不可改变，但是对象内的数据可以改变。如果是类的成员变量，则必须直接赋值。<br>
2、修饰方法，则方法无法被重写，但是可以被继承（即子类可以使用）。<br>
3、修饰类，则类无法被继承。<br>

#### 10、final修饰一个类的成员变量时，是引用不能变（=号左侧），还是引用的对象不能变（=号右侧）？
引用不能变，即此引用指向了一个固定的地址，但是被指向的对象不一定不能变，比如集合、数组、自定义类。

#### 11、this和super关键字的作用？
this是对象内部指代自身的引用，可以通过this调用成员变量，成员方法。当成员变量和局部变量存在同名问题时，可以用this引用来区分。<br>
super指代父类，可以通过super调用父类的成员变量，成员方法，构造函数。<br>

#### 12、为什么不允许类的静态方法使用类的非静态变量？
静态方法属于类本身，在类加载时也同步加载到内存中。而非静态变量属于类的实例对象，当类加载时，还没有类的实例对象，也就没有非静态变量，无法使用它。

#### 13、final和static的区别？
都可以修饰成员变量，成员方法。final还可以修饰类，表示不可被继承。static修饰的东西表示它属于这个类，而非类的实例，在类被加载时一并加载到内存，主要用于初始化等场景。

#### 14、int可以强转成byte吗？
可以，高24位丢失。

#### 15、char可以存储一个汉字吗？
Java默认采用Unicode编码，默认编码规则采用UTF-16(编码规则才是能否存储的关键，Character类的注释中有写是UTF-16，而且采用的是BE大端)，占2个字节，而char正好可以存储2个字节的数据，所以可以存储一个汉字。（可以看这个链接：https://blog.csdn.net/caoruntao_/article/details/108668319）<br>
UTF-16用两个字节表示一个字符，那么用两个字节表示必然存在字节序的问题(Byte Order Mark(BOM))，即大小端的问题。UTF-16根据BOM分为UTF-16BE(最低地址存放高位字节，编码前会放置FEFF)和UTF-16LE(最高地址存放高位字节，编码前会放置FFFE)

#### 16、byte类型127+1等于多少？
存储范围是-128 ~ 127，+1后会溢出，127的补码为0111 1111，+1后得到1000 0000，负数的补码转十进制：对各位取反0111 1111，转十进制127，加上负号-127，再减1，得到-128。

#### 17、为什么数组的起始索引是0不是1？
这个习惯来源于机器语言，那时要计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。将起始索引设为1要么浪费数组的第一个元素的空间，要么会花费额外的时间来将索引减1。

#### 18、Java中的基本数据类型和所占字节？
byte 8位1个字节，short 16位2个字节，int 32位4个字节，long 64位8个字节，char 16位2个字节，float 32位4个字节，double 64位8个字节

#### 19、Java中的数据类型提升？
为了保证计算的精确性，java在运算时会自动将低精度类型的数据向高精度类型转换，比如int和double相加，int会被转成double类型，再计算

#### 20、机器数、真值、原码、反码、补码
机器数：<br>
一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。<br>
比如：十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 1000 0011 。那么，这里的 0000 0011 和 1000 0011 就是机器数。<br>
真值：<br>
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3 而不是形式值131（ 1000 0011 转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。<br>
比如：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1<br>
原码：<br>
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：<br>
[+1]原 = 0000 0001 <br>
[-1]原 = 1000 0001 <br>
第一位是符号位。因为第一位是符号位，所以8位二进制数的取值范围就是：[1111 1111 , 0111 1111]，即[-127 , 127]。原码是人脑最容易理解和计算的表示方式。<br>
反码：<br>
反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。<br>
[+1] = [00000001]原 = [00000001]反 <br>
[-1] = [10000001]原 = [11111110]反 <br>
可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。<br>
补码：<br>
补码的表示方法是：正数的补码就是其本身。负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)<br>
[+1] = [00000001]原 = [00000001]反 = [00000001]补 <br>
[-1] = [10000001]原 = [11111110]反 = [11111111]补 <br>
对于负数，补码的表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。<br>
原因：<br>
因为[0000 0000]补、[1000 0000]补都表示0，一个+0，一个-0，显然这有些浪费，故将-0的补码，对应的真值设计成-128，-128是没有原码和反码的。这就是为什么8位二进制，使用原码或反码表示的范围为[-127 , +127]，而使用补码表示的范围为[-128 , 127]。<br>
int表示的取值范围就是[-2的31次方 , 2的31次方 - 1]<br>
原链接：https://cloud.tencent.com/developer/article/2038347<br>

#### 21、Object类常用方法？
clone浅复制需要实现Cloneable接口才可以调用、getClass、toString、finalize、equals、hashCode、wait、notify、notifyAll

#### 22、equals的特性？
java语言规范要求equals方法具有下面的特性：<br>

自反性：对于任何非空引用x, x.equals(x)应该返回true;<br>
对称性：对于任何引用x和y, 有y.equals(x)返回true,x.equals(y)也应该返回true;<br>
传递性：对于任何引用x,y,z, 如果x.equals(y)返回true, y.equals(z)返回true, 那么x.equals(z)也应该返回true;<br>
一致性：如果x,y引用的对象没有发生变化, 反复调用x.equals(y)应该返回同样的结果;<br>
对于任意非空引用x, x.equals(null)返回false;<br>

#### 23、关于hashCode方法？
该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。hashCode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。<br>
当集合需要添加新的对象时，先调用这个对象的hashCode()方法，得到对应的hash值，实际上hashmap中会有一个table保存已经存进去的对象的hash值，如果table中没有该hash值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。<br>

#### 24、equals和hashCode的关系？
如果equals为true，hashCode一定相等；如果equals为false，hashCode也可能相等；如果hashCode值不等，equals一定不等；重写equals方法时，一定要重写hashCode方法。<br>
hashCode像是人的名字，而equals则是人的本身，本身相等说明是同一个人，那名字一定相等。但是名字一样，不一定是同一个人。

#### 25、String str = "i" 与 String str = new String("i") 一样吗？
不一样，前者引用直接指向常量池中的"i"，后者指向的是堆内存中的一个对象，再由这个对象指向常量池中的"i"。

#### 26、String s = "123"; s = s + "456"; 这两行代码执行后，原始的 String 对象中的内容到底变了没有？
没有变，Java中String中的内容是不可变的，+号是产生了一个新的字符串对象，并将s指向这个新对象的引用。

#### 27、如何将字符串反转？
使用 StringBuilder 的 reverse() 方法

#### 28、String类常用方法？
length、charAt、indexOf、substring、contains、startsWith、endWith、isEmpty、getBytes、toCharArray、concat、toLowerCase、toUpperCase、replace、trim、

#### 29、String s = new String("123"); 创建了几个字符串对象？
第一次调用，产生两个对象，堆内存一个，字符串常量池一个。第二次调用，只会在堆内存产生一个对象。

#### 30、想新建一个java.lang.String类，能建成功吗？这个类会被类加载器加载吗？为什么？
不能成功新建一个名为java.lang.String的类，这个类也不会被类加载器加载，因为这样做违反了Java的命名规范和类加载机制。

#### 31、String类可以被继承吗？
不可以，final的。

#### 32、String，Stringbuffer，StringBuilder 的区别？
String不可修改，其他两个可以修改。String和StringBuffer都是线程安全的，StringBuilder不是线程安全的。性能方面，StringBuilder最快，其次StringBuffer，最后String，因为它很大概率要创建新对象。String存储在常量池中，其他存储在堆内存中。

#### 33、"+" 连接符的效率为何低？
JVM会隐式创建StringBuilder，在循环里，使用+会导致创建大量对象，建议在循环外显示创建StringBuilder对象。还有一种特殊情况，如果"+"拼接的是常量池中的字符串时，编译器会进行优化，直接将两个字符串常量拼接好。<br>
所以"+"连接符对于直接相加的字符串常量效率很高，因为在编译期间便确定了它的值；但对于间接相加的情况效率就会变低，建议单线程时使用StringBuilder，多线程时使用StringBuffer替代。

#### 34、说说缓冲区数据结构bytebuffer？
缓冲区是由具有相同类型的数值构成的数组，Buffer是一个抽象类，它有很多子类，包括ByteBuffer、CharBuffer、DoubleBuffer、IntBuffer、LongBuffer、ShortBuffer。<br>
每个缓冲区都具有4个属性：容量capacity、下一次要读写的位置position、读取界限limit（容量1024，但是界限是512，则512后的数据都不可读写，那么缓冲区的实际使用大小是512）、标记mark<br>
标记，一个备忘位置。保存某个时刻的position指针的值，通过调用mark()实现，当mark被置为负值时，表示废弃标记。标记在设定前是未定义的(undefined)。使用场景是，假设缓冲区中有 10 个元素（0-9），position 目前的位置为 2(也就是如果get的话是第三个元素)，现在只想发送 6 - 10 之间的缓冲数据，此时我们可以 buffer.mark(buffer.position())；即把当前的 position 记入 mark 中，然后 buffer.position(6)；此时发送给 channel 的数据就是 6 - 10 的数据。发送完后，我们可以调用 buffer.reset() 使得 position = mark，因此这里的 mark 只是用于临时记录一下位置用的。<br>

使用缓冲区的主要目的是执行读写循环操作。Buffer及其子类都不是线程安全的。<br>
假设我们有一个缓冲区，在一开始，它的位置是0，界限等于容量。我们不断地调用put将值添加到这个缓冲区中，当我们耗尽所有的数据或者写入的数据量达到容量大小时，就该切入到读操作了。<br>
这时可以调用flip方法将界限设置到当前位置，并把指针位置复位到0。现在在remaining方法返回正数时（它返回的值是界限 - 指针位置），不断地调用get。在我们将缓冲区中所有的值都读完后，调用clear使缓冲区为下一次写循环做好准备。clear方法将指针位置复位到0，并将界限复位到容量。<br>
如果想重读缓冲区，可以使用 rewind 或 mark/reset 进行复位。然后可以 用某个通道的数据填充缓冲区，或者将缓冲区的内容写出到通道中。<br>

```Java
ByteBuffer buffer = ByteBuffer.allocate(RECORD_SIZE);
channel.read(buffer); // 将通道里的数据，写入buffer
channel.position(newpos);
buffer.flip(); // 进入读模式
channel.write(buffer); // 将buffer里的数据读进通道
```

#### 35、Java 创建对象有几种方式？
new（构造函数）、反射、clone、序列化反序列化。这三种应该是模式，而不是创建对象的本质：依赖注入、工厂模式、Builder构建器模式

#### 36、说说对象创建的过程？
1\当虚拟机执行到 new 关键字时，首先会去运行时常量池中查找该引用所指向的类有没有被虚拟机加载，如果没有被加载，那么会进行类的加载过程，如果已经被加载，那么进行下一步。<br>
2\当类元信息被加载之后，我们就可以从常量池找到对应的类元信息，通过类元信息来确定类型和后面需要申请的内存大小。<br>
3\对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。（分配完内存后，需要对对象的字段进行零值初始化，对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值，这也就解释了为什么这些字段在不需要进程初始化时候就能直接使用）<br>
4\分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashCode，GC分代年龄等信息<br>
5\然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。执行对象的构造方法，这里做的操作才是程序员真正想做的操作，例如初始化其他对象啊等等操作，至此，对象创建成功。<br>
原链接：https://zhuanlan.zhihu.com/p/143743569 <br>
JVM先查找class文件，加载class到内存，创建class对象（初始化静态常量和加载静态方法），堆内存分配空间，创建对象并给成员变量赋0值，执行所有初始化操作（成员变量赋值等），执行构造器

#### 37、构造函数，构造代码块（非静态代码块），静态代码块执行顺序？
静态代码块先执行，因为类一加载，就执行了，用于在类的层级上进行一些初始化操作，即给类做初始化。（它的执行优先于主函数即main方法）<br>
其次是构造代码块，也就是非静态代码块，创建每个对象时，不管调用哪个构造函数，都会先调用构造代码块，用于在实例对象的层级上进行统一的初始化操作，即给所有该类的对象们做初始化<br>
最后是构造函数，用于给具体某个实例对象做初始化操作。<br>

先父再子，先静再动，先变量，再代码块，再构造，即：（父类静态变量、父类静态代码块），（子类静态变量、子类静态代码块），父类变量，父类代码块，父类构造函数，子类变量，子类代码块，子类构造函数<br>

#### 38、对象间的关系？
一般->特殊 关系：<br>
继承、实现

整体->部分 四种关系：<br>
依赖Dependency（一般而言，依赖关系在Java语言中体现为局部变量、方法的形参，或者对静态方法的调用。单向。依赖注入的说法，是不是就是这样来的？）<br>
关联Association（是类与类之间的联接，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。一对多，多对一，在Java语言中，关联关系一般使用成员变量来实现。）<br>
聚合Aggregation（是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但关联关系所涉及的两个类是处在同一层次上的，而聚合关系中的两个类是处在不同层次上的，一个代表整体，另一个代表部分。）<br>
组合Composition（是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。）<br>

依赖关系的范围更小，比如人买车的动作，需要依赖车，车作为形参。<br>
关联关系则是人已经拥有了车，把车放在人的成员变量里。<br>
聚合关系则是把房子、车子等作为资产，聚合到一起来管理，而人的成员变量里只需要关联一个“资产”变量即可，不再需要显示的关联“车”这个变量。<br>
组合关系和聚合关系很像，但是表达的关系更紧密，部分离开了整体便失去了意义，比如人的手和脚。

#### 39、隐式参数和显示参数？
显式参数是我们在调用方法时明确传递的参数。这些参数在方法声明中作为方法签名的一部分出现，并且在调用时需要提供具体的值。<br>
隐式参数不是由程序员明确传递的，而是系统自动传递的。最常见的例子就是this关键字，它引用了当前对象本身。<br>
在非静态方法中，我们可以使用this关键字来引用当前对象的属性或方法。这个this就是隐式参数，因为它不需要我们显式地传递给方法，但方法内部可以访问它。<br>
另一个隐式参数是静态方法中的class参数，它指向定义该方法的类，可以通过ClassName.class的形式获取，这也是一种隐式参数。<br>

简而言之，隐式参数就是，你没有传递，但是你能用

#### 40、Java的可变参数？
Java 1.5 引入可变参数，书写方式是public void fun(int... arg){}，允许传入任意数量的相同类型的参数，方法内部当作数组处理。<br>
可变参数可以用于方法重载，在重写时，子类方法也可以使用可变参数，但需要保持参数类型的兼容性。<br>
可变参数一般用于日志记录，数学计算等场景，但过度使用可变参数可能会导致代码难以理解和维护，因此需要谨慎使用。<br>

谈到可变参数，为什么会谈到方法重载，因为可变参数的出现，使得以往由于参数数量不同而需要书写多个同名方法的情况得到改善，使用可变参数后只需要写一个方法就可以解决这个问题。<br>
但是同时也引出新的问题，哪个方法会被JVM优先匹配到并调用？答案是可变参数的方法优先级最最最最低！实在没有可匹配的才会用可变参数的方法，可以看看这个：https://www.cnblogs.com/vipstone/p/15769601.html

#### 41、普通类和抽象类的区别？
意义：用于表示具体的实体或对象；用于表示一类具有共同特性的实体或对象。<br>
普通方法：可以有；可以有。<br>
抽象方法：一定不能有；有没有都行。<br>
实例化：可以；不可以。<br>
继承：可以；可以。<br>

#### 42、接口和抽象类的区别？
意义：比抽象类更抽象，用于表明一种能力，实现了某个接口，就相当于对外表示这个类拥有了某种能力，比抽象类更灵活，只要符合拥有这项能力的类就都可以实现这个接口，即不要求是同一类物体；而抽象类是将同一类物体的共同特性总结提炼出来，形成一个父类，在类的层次结构管理上更有意义。<br>
普通方法：不能有；可以有。<br>
抽象方法：有没有都行；有没有都行。<br>
成员变量：不能有（可以定义静态常量，即 public static final 的）；可以有<br>
实例化：不可以（且没构造函数）；不可以（但有构造函数）<br>
继承：可以多继承（A implements D, E）；不可以多继承（A extends C）。<br>

#### 43、为什么方法的返回类型不同不算重载？
这里涉及到方法的签名，方法签名是由：方法名称 + 参数类型 + 参数个数组成的一个唯一值，这个唯一值就是方法签名，而 JVM 就是通过这个方法签名来决定调用哪个方法的。<br>
从方法签名的组成规则我们可以看出，方法的返回值类型不是方法签名的组成部分，所以当同一个类中出现了多个方法名和参数相同，但返回值类型不同的方法时，JVM 就没办法通过方法签名来判断到底要调用哪个方法了。<br>
为什么没有把返回值类型作为方法签名的组成部分？因为一个方法的返回值可能被使用，也可能不被使用，所以返回值类型不足以用来让 JVM 判断要调用哪个方法。<br>

#### 44、重载方法的调用匹配原则？
重载方法的调用有 5 个匹配原则：精准匹配、基本类型自动向上转型匹配（int转long，也即有形参是long的方法，就可以被调用）、自动拆/装箱匹配（int转Integer）、按照继承路线依次向上匹配（int转Object）、可变参数匹配（实在没招了，才走可变参数的重载方法）。

#### 45、接口中被default修饰的方法是什么？
Java 8 引入的，可以在接口中使用default修饰方法，根普通方法一样，实现此接口的子类不需要实现这个default修饰的方法，并且可以调用接口中的这个方法（例如C.super.b()，C是接口，b是default方法）。<br>
特别的：假如父类A有b方法，接口C也有b方法（default修饰），此时有class D extends A implements C，那么D调用b方法时，将使用父类A中的b方法，而不是接口C中的b方法。<br>
还有：假如D类实现了两个接口E,F，俩接口中都有b方法，那么D类必须重写b方法，因为调用时不知道使用哪个接口里的b方法。<br>

默认方法可以解决接口升级的问题。可以在接口中定义几个default方法，分别对应不同版本的默认实现。实现类要拥有接口的能力，可以直接调用对应版本的默认实现，或者对默认实现进行重写<br>
子类实例可以直接调用接口中的default方法，但是接口中的static方法，不可以被子类实例调用，它只能在接口内部，或者接口的实现类内部调用。<br>

#### 46、接口中为什么要支持静态方法？
Java 8 引入的，可以在接口中使用static修饰方法，为了将和接口相关的方法，内聚到接口中，避免创建新的对象来存放这些方法。Java 9 还引入了私有方法private。<br>

#### 47、Java中多态的实现原理？
多态机制包括静态多态（编译时多态）和 动态多态（运行时多态）。静态多态比如说重载；动态多态一般指在运行时才能确定调用哪个方法。我们通常所说的多态一般指运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直等到运行时才能确定。<br>
多态实现方式：继承一个类 或者 实现接口。多态的核心在于子类对 父类方法 的改写 或 对接口方法 的实现，以取得在运行时不同的执行效果。<br>

多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java 对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevirtual)和接口引用调用(invokeinterface)的实现则有所不同。<br>

类引用调用的大致过程为：Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。<br>

方法表是实现动态调用的核心。方法表存放在方法区中的类型信息中。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一项都是对应方法的指针。这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。<br>

一个类的方法表的方法顺序是：Object类的方法，父类的方法，子类的方法，因此前面的方法的偏移量都是固定的，而方法表条目会指向具体的方法地址，当JVM调用某个具体方法时，先拿父类的方法表，查看偏移量，然后拿具体类的方法表，根据偏移量看是否重写了父类方法，如果重写了就调用，如果没重写，就拿出父类的方法表调用对应偏移量的方法。<br>

类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。实例调用 (invokevirtual) 则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokevirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。<br>

接口由于可以多继承，所以接口方法的调用就比较复杂，需要逐个查方法表中的方法，因此接口方法的调用要比类方法的调用慢。

#### 48、方法区和运行时常量池？
方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br> 
运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。方法区的内存回收目标是针对常量池的回收及对类型的卸载。<br>

#### 49、构造函数可以被重写吗？
重写的概念：当一个子类继承一个父类，而子类中的方法与父类中的方法的名称，参数类型和个数都完全一致时，就称子类中的这个方法重写了父类中的方法（返回值类型必须小于等于父类，方法访问范围必须大于等于父类，抛出的异常必须小于等于父类）。
首先，构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以根本谈不上继承。又由于构造器不能继承，所以就不能被重写。但是，在同一个类中，构造器是可以被重载的。

#### 50、Java内部类？
静态内部类、成员内部类、局部内部类和匿名内部类。<br>
内部类可以访问外部类的所有成员（包括私有成员），并且可以隐藏外部类的某些成员。<br>
每个内部类都可以独立的继承一个类，所以无论外部类是否继承了某个类，内部类依然可以继承其他类，这就完美的解决了Java没有多继承的问题。<br>
可以有效的将有一定关系的类组织在一起，又可以对外界有所隐藏。<br>
方便编写事件驱动程序。<br>
方便编写多线程代码。<br>

#### 51、Java Bean 命名规范？
类名首字母大写并且驼峰式、成员变量名首字母小写并且驼峰式、成员变量私有private同时提供Setter和Getter方法、应该提供无参构造、避免使用Java保留字

#### 52、成员内部类和静态内部类的区别？
成员内部类默认持有外部类的引用。<br>
成员内部类可以访问外部类的所有成员变量和成员方法（私有的成员也可以！）。静态内部类只能访问外部类的静态成员变量和静态成员方法（与是不是私有的无关，它都是内部类了，当然可以访问外部类私有的成员）。<br>
静态内部类的实例化不需要依赖外部类，可以直接实例化（new Outer.StaticInner()）。成员内部类的实例化需要先实例化外部类对象，再实例化内部类对象（new Outer().new Inner()）。<br>
静态内部类可以作为Builder模式用于创建外部类的实例，也可以作为对代码结构的统一管理，即将属于外部类的一些类定义成静态内部类，这样创建内部类时就能知道这些内部类是属于哪个外部类的。<br>
成员内部类主要用于封装，或者解决不能多继承问题。

#### 53、throw 和 throws 的区别？
throw 代表一个动作，用于在程序中明确地抛出一个异常对象。它出现在方法体内部，可以作为单独的语句使用。
throws 代表一种状态，用于声明一个方法可能会抛出的异常。它出现在方法声明中，不能单独使用。

#### 54、final、finally、finalize 有什么区别？
final 可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写。<br>
finally 用于抛异常，finally 代码块内语句无论是否发生异常都会执行，常用于一些流的关闭。<br>
finalize 方法用于垃圾回收。

#### 55、try catch finally 的执行顺序？
从 try 中第一行代码开始执行，执行到出现异常的代码，JVM 会创建一个异常对象。<br>
判断 catch 是否能捕获到 JVM 创建的这个异常对象，如果捕获到就跳到 catch 代码块中，不会结束程序，继续执行 catch 中的代码逻辑；如果捕获不到，直接打印异常信息并结束程序。<br>
如果 try 中没有异常，则执行完 try 中代码，跳过 catch，进入 finally 代码块。<br>
如果 try 和 catch 中有 return，则是 try -> finally -> return （注意，如果写return，那么try和catch这俩分支里都要有return语句，或者直接写代码块外面。finally内部也可以写return，但是编辑器不建议）<br>

```Java
private static int a() {
        try {
            int a = 1 / 0;
        } finally {
            System.out.println("finally");
        }
        return 1;
}
结论：先走finally，再抛异常

private static int a() {
        try {
            int a = 1 / 0;
        } finally {
            System.out.println("finally");
            return 1;
        }
}
结论：不会抛异常，因为方法结束了，没有机会抛出
```

#### 56、常见的异常类有哪些？
NullPointerException、IOException、IndexOutOfBoundsException、FileNotFoundException、ClassCastException、NoSuchMethodException、NumberFormatException、IllegalArgumentException

#### 57、开发中，你是如何处理异常的？
看这个异常需要由谁来处理，如果需要让调用方处理，则需要在方法上声明要抛出的异常类型；调用了会抛出异常的方法时，要对可能抛出的异常类型逐一针对处理；<br>
如果由方法内部处理，那么使用try-catch代码块处理；异常尽量不抛给用户，即尽量不终止程序，而是妥善解决，给用户提示信息。

#### 58、NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
NoClassDefFoundError 是JVM运行时通过classpath加载类时，找不到对应的类而抛出的错误。ClassNotFoundException 在编译过程中可能出现此异常，在编译过程中必须将其抛出。<br>
NoClassDefFoundError 的发生场景：类依赖的class或jar不存在；或类文件存在，但是在不同的域中，简而言之，就是找不到<br>
ClassNotFoundException 的发生场景：调用Class.forName("类名")方法时，找不到指定的类；调用ClassLoader中的findSystemClass()方法时，找不到指定的类

#### 59、什么是 Java 序列化？什么情况下需要序列化？
序列化就是把内存里面的对象转化为字节流，以便用来实现存储或者传输。序列化需要保证传输双方对内容格式的统一和识别，一般采用json或者xml <br>
序列化是通过实现Serializable接口，该接口没有需要实现的方法，只是为了标注该对象是可被序列化的。<br>
反序列化就是把从文件或者网络上获取到的对象的字节流，转化成内存里的对象实例的过程。<br>

注意事项：序列化ID用于区分对象的版本，需要保证唯一性。静态变量不会被序列化，因为序列化保存的是对象的状态，而静态变量属于类的状态。transient 修饰的字段代表对象的临时数据，不会被序列化和反序列化。<br>
当一个父类实现序列化，子类自动实现序列化；而子类实现了 Serializable 接口，父类也需要实现 Serializable 接口。<br>
当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。（这是解决深拷贝问题）

#### 60、深拷贝和浅拷贝的区别？
浅拷贝，指的是重新分配一块内存，创建一个新的对象，指针指向被复制对象的同一块内存地址，两个对象中任一个对象被修改，另一个对象也会被影响；
深拷贝：指的是重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。这意味着深拷贝不仅复制了对象本身，还复制了对象所引用的所有其他对象。因此，新对象和原对象没有任何关联，对其中一个对象的修改不会影响另一个对象。
