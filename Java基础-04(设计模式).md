### 为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：

#### 1、开闭原则
由Bertrand Meyer提出的开闭原则（Open Closed Principle），对拓展开放，对修改关闭。即：拓展增加新功能时是方便的。且增加新功能时，能不修改老代码就不修改，这是最好的。

#### 2、里氏替换原则
里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。

#### 3、23种设计模式
三类：创建型、结构型和行为型

#### 4、创建型
创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。

创建型模式包括：

* 工厂方法：Factory Method
* 抽象工厂：Abstract Factory
* 建造者：Builder
* 原型：Prototype
* 单例：Singleton

##### 工厂方法（简单工厂）
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品。<br>
工厂Factory是抽象的，它产出的产品Product也是抽象的。也就是尽量都是面向接口编程的，不直接依赖具体的子类类型。<br>
工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品（为什么用工厂，这就是其中一个好处），完全可以返回缓存的产品，从而提升速度并减少内存消耗。<br>
实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。（Integer.valueOf()方法） <br>
调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。<br>

##### 抽象工厂（工厂都抽象了，允许工厂有多种实现）
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>
抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；<br>
抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。

##### 建造者（Builder）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

##### 原型模式（写个copy方法，或者实现clone方法，没啥意思。） 
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

##### 单例
保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

* 构造私有
* 实例唯一且私有
* 有公共方法对外提供实例

枚举类（简单省事），静态常量方式（靠类加载器保证唯一），静态内部类方式（延迟加载），饿汉式，懒汉式<br>
真正的单例，应该避免序列化和反序列化以及反射等构建多个实例的隐患。

#### 5、结构型
结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。

结构型模式有：

* 适配器
* 桥接
* 组合
* 装饰器
* 门面
* 享元
* 代理

##### 适配器（承担转换功能）
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？

##### 桥接（优先用组合而非继承的方式，去组织和实现功能的扩展）
将抽象部分与它的实现部分分离，使它们都可以独立地变化。
假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类。如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。<br>
所以，桥接模式就是为了避免直接继承带来的子类爆炸。<br>
首先定义抽象类Car，它引用一个Engine。使用桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果要增加一个品牌，只需要针对BrandCar（Car的抽象子类）派生一个子类，任何BrandCar的子类都可以和任何一种Engine自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。

即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。

##### 组合（套娃，树形结构）
将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。<br>
可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口，作为容器节点的ElementNode又可以添加任意个Node，这样就可以构成层级结构。

##### 装饰器（核心功能是一个体系，附加功能是一个体系，附加功能使用装饰器设计，使多个附加功能可以自由组合去装饰一个核心功能）
动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。
我们在IO的Filter模式一节中其实已经讲过装饰器模式了。在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream()这些InputStream都是最终数据源。<br>
现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。<br>
Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。
```Java
// 创建原始的数据源:
InputStream fis = new FileInputStream("test.gz");
// 增加缓冲功能:
InputStream bis = new BufferedInputStream(fis);
// 增加解压缩功能:
InputStream gis = new GZIPInputStream(bis);
```
Decorator模式有什么好处？<br>
它实际上把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。<br>
如果我们要新增核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。

##### 门面（多个子接口组合成一个总接口，没啥意思。）
为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

##### 享元
运用共享技术有效地支持大量细粒度的对象。<br>
享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。<br>
享元模式在Java标准库中有很多应用。我们知道，包装类型如Byte、Integer都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以Integer为例，如果我们通过Integer.valueOf()这个静态工厂方法创建Integer实例，当传入的int范围在-128~+127之间时，会直接返回缓存的Integer实例。

##### 代理
为其他对象提供一种代理以控制对这个对象的访问。

* 远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。
* 虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。<br>
  JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。
* 保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。
* 智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。

#### 3、行为型
行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。

行为型模式有：

* 责任链
* 命令
* 解释器
* 迭代器
* 中介
* 备忘录
* 观察者
* 状态
* 策略
* 模板方法
* 访问者

##### 责任链（每个处理器都有机会处理请求，如拦截器等应用）
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br>
责任链模式是一种把多个处理器组合在一起，依次处理请求的模式；责任链模式的好处是添加新的处理器或者重新排列处理器非常容易；责任链模式经常用在拦截、预处理请求等。

##### 命令
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。<br>
命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。<br>
应用场景，比如支持undo、redo操作，那么每个操作就是一个命令，将这些操作装入集合，就很方便进行撤销和恢复步骤了。

##### 解释器（正则表达式就有对应的解释器，了解即可，日常很少用这个设计模式）
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

##### 迭代器（集合中广泛使用）
提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

##### 中介（类似Controller，把交互逻辑组织到了另外一个地方）
用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>
中介模式是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。<br>
MVC和MVVM模式都是对中介模式的扩展。

##### 备忘录
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br>
备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。

##### 观察者
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

##### 状态（强调内部变化）
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。状态模式的关键设计思想在于状态切换，状态切换后，对外界的响应也就发生了变化，比如从男性变成了女性。

##### 策略（依赖外部传入，将函数作为参数，传入一个高阶函数，执行策略就是执行这个高阶函数）
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

##### 模板方法
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>
它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。<br>
可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。<br>
为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。<br>
Java标准库也有很多模板方法的应用。在集合类中，AbstractList和AbstractQueuedSynchronizer都定义了很多通用操作，子类只需要实现某些必要方法。

##### 访问者（将实际要做的操作和数据分离，把操作封装成访问者，去访问数据）
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。

实际上，Java标准库提供的Files.walkFileTree()已经实现了一个访问者模式：
```Java
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;

public class Main {
    public static void main(String[] args) throws IOException {
        Files.walkFileTree(Paths.get("."), new MyFileVisitor());
    }
}

// 实现一个FileVisitor:
class MyFileVisitor extends SimpleFileVisitor<Path> {
    // 处理Directory:
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
        System.out.println("pre visit dir: " + dir);
        // 返回CONTINUE表示继续访问:
        return FileVisitResult.CONTINUE;
    }

    // 处理File:
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        System.out.println("visit file: " + file);
        // 返回CONTINUE表示继续访问:
        return FileVisitResult.CONTINUE;
    }
}
```

