### 为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：

#### 1、开闭原则
由Bertrand Meyer提出的开闭原则（Open Closed Principle），对拓展开放，对修改关闭。即：拓展增加新功能时是方便的。且增加新功能时，能不修改老代码就不修改，这是最好的。

#### 2、里氏替换原则
里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。

#### 3、23种设计模式
三类：创建型、结构型和行为型

#### 4、创建型
创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。

创建型模式包括：

* 工厂方法：Factory Method
* 抽象工厂：Abstract Factory
* 建造者：Builder
* 原型：Prototype
* 单例：Singleton

##### 工厂方法（简单工厂）
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品。<br>
工厂Factory是抽象的，它产出的产品Product也是抽象的。也就是尽量都是面向接口编程的，不直接依赖具体的子类类型。<br>
工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品（为什么用工厂，这就是其中一个好处），完全可以返回缓存的产品，从而提升速度并减少内存消耗。<br>
实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。（Integer.valueOf()方法） <br>
调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。<br>

##### 抽象工厂（工厂都抽象了，允许工厂有多种实现）
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>
抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；<br>
抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。

##### 建造者（Builder）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

##### 原型模式（写个copy方法，或者实现clone方法，没啥意思。） 
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

##### 单例
保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

* 构造私有
* 实例唯一且私有
* 有公共方法对外提供实例

枚举类（简单省事），静态常量方式（靠类加载器保证唯一），静态内部类方式（延迟加载），饿汉式，懒汉式<br>
真正的单例，应该避免序列化和反序列化以及反射等构建多个实例的隐患。

#### 5、结构型
结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。

结构型模式有：

* 适配器
* 桥接
* 组合
* 装饰器
* 门面
* 享元
* 代理

##### 适配器（承担转换功能）
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？

##### 桥接（优先用组合而非继承的方式，去组织和实现功能的扩展）
将抽象部分与它的实现部分分离，使它们都可以独立地变化。
假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类。如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。<br>
所以，桥接模式就是为了避免直接继承带来的子类爆炸。<br>
首先定义抽象类Car，它引用一个Engine。使用桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果要增加一个品牌，只需要针对BrandCar（Car的抽象子类）派生一个子类，任何BrandCar的子类都可以和任何一种Engine自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。

即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。

##### 组合（套娃，树形结构）
将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。<br>
可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口，作为容器节点的ElementNode又可以添加任意个Node，这样就可以构成层级结构。

##### 装饰器（核心功能是一个体系，附加功能是一个体系，附加功能使用装饰器设计，使多个附加功能可以自由组合去装饰一个核心功能）
动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。
我们在IO的Filter模式一节中其实已经讲过装饰器模式了。在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream()这些InputStream都是最终数据源。<br>
现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。<br>
Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。
```Java
// 创建原始的数据源:
InputStream fis = new FileInputStream("test.gz");
// 增加缓冲功能:
InputStream bis = new BufferedInputStream(fis);
// 增加解压缩功能:
InputStream gis = new GZIPInputStream(bis);
```
Decorator模式有什么好处？<br>
它实际上把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。<br>
如果我们要新增核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。

##### 门面（多个子接口组合成一个总接口，没啥意思。）
为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

##### 享元
运用共享技术有效地支持大量细粒度的对象。<br>
享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。<br>
享元模式在Java标准库中有很多应用。我们知道，包装类型如Byte、Integer都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以Integer为例，如果我们通过Integer.valueOf()这个静态工厂方法创建Integer实例，当传入的int范围在-128~+127之间时，会直接返回缓存的Integer实例。

##### 代理
为其他对象提供一种代理以控制对这个对象的访问。

* 远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。
* 虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。<br>
  JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。
* 保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。
* 智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。

#### 3、行为型
行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。

行为型模式有：

* 责任链
* 命令
* 解释器
* 迭代器
* 中介
* 备忘录
* 观察者
* 状态
* 策略
* 模板方法
* 访问者
