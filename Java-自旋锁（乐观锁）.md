### 自旋锁（spinlock）

1、为了解决多线程操作资源的问题，需要有锁，谁获得了锁，谁有权操作资源，但是没有获得锁的线程，它应该做什么？<br>
两种方式：<br>
自旋锁，一直尝试获取锁，不阻塞。<br>
互斥锁，把自己阻塞起来，等待调度。<br>

2、自旋锁的原理
自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就**不需要做内核态和用户态之间的切换**进入阻塞状态，它们只需要等一等（自旋），等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。

3、自旋锁的优缺点
自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用CPU做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要CPU的线程又不能获取到CPU，造成CPU的浪费。所以这种情况下我们要关闭自旋锁。

4、简单的自旋锁有个大的问题，谁先拿到锁，谁就获得了资源，但是其他线程可能永远获得不了锁，不公平！为了解决这个问题，有很多其他实现，叫做**排队自旋锁**，比如：TicketLock、MCSLock、CLHLock

5、TicketLock：每个线程在尝试获取锁之前都会先获取一个唯一的票号，表示自己的顺序。然后，线程会不断轮询当前的服务号，直到自己的票号与服务号相等时，才能获取到锁。

场景：适用于获取锁的时间比较均匀的场景，因为它可以保证公平性，避免某个线程一直占用锁的情况。

缺点：TicketLock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量 queueNum，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。

6、CLHLock（Craig, Landin, and Hagersten locks）和 MCSLock（McKenney and Slingwine locks）都是自旋锁的实现，它们的设计目标都是为了实现高性能和公平性。然而，它们在实现方式、性能和适用场景上存在一些差异。以下是对CLHLock和MCSLock性能的比较：
1. 实现方式：
	* CLHLock：基于链表的可扩展、高性能、公平的自旋锁。申请线程只在本地变量上自旋，不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。
	* MCSLock：也采用链表结构，但每个节点包含两个主要部分：一个表示锁是否被持有的标志（locked）和一个指向下一个等待线程的指针（next）。MCSLock的独特之处在于其懒惰性的锁传递机制，即只在真正需要时才进行锁的传递。
2. 性能特点：
	* CLHLock：由于其基于链表的结构和简单的自旋机制，CLHLock在高度争用（多个线程频繁争抢同一把锁）的情况下表现出色。它确保了无饥饿性，提供先来先服务的公平性，且扩展性较好。然而，在低争用或单线程环境下，其性能可能并不突出，因为仍然需要进行一些必要的链表操作和自旋。
	* MCSLock：MCSLock在设计上考虑了更多的优化，以减少不必要的开销。例如，当线程发现锁被占用时，它会立即进入休眠状态，而不是像CLHLock那样持续自旋。这种设计使得MCSLock在处理大量线程但争用不激烈的情况下具有更高的效率。此外，MCSLock也提供了良好的公平性和可扩展性。
3. 适用场景：
	* CLHLock：适用于高度争用的场景，如多线程频繁访问共享资源的情况。其公平性和无饥饿性保证使得所有线程都能按照到达的顺序获得锁，从而避免了某些线程长时间得不到服务的问题。
	* MCSLock：更适用于线程数量较多但争用不激烈的场景。通过优化休眠和唤醒机制，MCSLock能够降低系统的整体开销，提高资源的利用率。
综上所述，CLHLock和MCSLock在性能上各有优势，具体选择哪种锁取决于实际的应用场景和需求。在高度争用的场景下，CLHLock可能更为合适；而在线程数量较多但争用不激烈的场景下，MCSLock可能具有更好的性能表现。
