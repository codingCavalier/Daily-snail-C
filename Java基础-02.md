看看这个哥们总结的：https://www.javacn.site/interview/basic/

#### 1、finally 中的代码一定会执行吗？
不一定。<br>
当try中有System.exit()方法时，程序会立即终止，finally中的代码将没有机会执行。<br>
当try中有Runtime.getRuntime().halt()方法时，程序也会立即终止，并且不会执行Hook方法和终结器。<br>
当try中有死循环或者死锁导致程序无法跳出try代码块时。<br>
非程序性的，例如 JVM崩溃了，或者停电了。<br>

#### 2、什么是 Hook 方法？
在编程中，钩子方法（Hook Method）是一种由父类提供的空或默认实现的方法，子类可以选择性地重写或扩展该方法，以实现特定的行为或定制化逻辑。<br>
钩子方法可以在父类中被调用，以提供一种可插拔的方式来影响父类的行为。钩子方法通常用于框架或模板方法设计模式中。框架提供一个骨架或模板，其中包含一些已经实现的方法及预留的钩子方法。<br>
具体的子类可以通过重写钩子方法来插入定制逻辑，从而影响父类方法的实现方式。

#### 3、ArrayList 和 LinkedList ？
都是List接口的实现类。<br>
底层实现：ArrayList是基于动态数组的数据结构；LinkedList是基于链表的数据结构。<br>
随机访问的性能不同：ArrayList 优于 LinkedList <br>
插入删除性能不同：LinkedList 优于 ArrayList <br>

#### 4、ArrayList 和 Vector ？
都是List接口的实现类，底层都是动态数组的实现。<br>
Vector是线程安全的，因此性能差于ArrayList。<br>
容量增长方式不同，ArrayList是增加一半（会频繁扩容）；而Vector是翻倍，所以后者适合大量数据的存储。

#### 5、为什么 ConcurrentHashMap 不能插入 null ？
HashMap 允许key和value都是null的。<br>
ConcurrentHashMap 都不允许。直接原因是源码中不支持插入null，会抛出空指针异常。深层原因是它的使用场景是多线程环境，也就是并发环境，如果允许null存在，就会出现二义性问题。<br>

二义性问题：<br>
所谓的二义性问题指的是代码或表达式存在多种理解或解释，导致程序的含义不明确或模糊。<br>
即null可以理解成“null”值，也可以理解成“没有”。HashMap是运行在单线程环境下，我们可以通过containsKey(null)来判断 “我们通过get()所得到” 的 null 是真实存在的null（null值），还是因为不存在这个key而返回的null（表示没有）。<br>
而ConcurrentHashMap却不能通过这样的方式（containsKey(null)）来判断，因为它运行在多线程环境中，当我们判断containsKey时，可能另一个线程此时存入了null值，所以没有办法保证解释清楚这个null的具体含义。<br>

#### 6、HashMap 和 HashTable ？
都是Map接口的实现类。前者不是线程安全的，后者是线程安全的。HashMap允许null的key和value，HashTable不允许null的key（因为要计算hash值，它没做特殊处理，HashMap做了特殊处理），也不允许null的value（原因也是二义性问题）。

#### 7、HashMap 和 HashSet ？
HashSet实现了Set接口，用于存储对象。HashMap实现了Map接口，用于存储键值对。<br>
HashSet底层是用HashMap实现的，将自己的值存储到HashMap的Key里面。<br>
HashSet不允许值重复。HashMap不允许键重复。

#### 8、HashMap 里的负载因子，为什么是 0.75 ？
HashMap 负载因子 loadFactor，也叫做扩容因子和装载因子，它是 HashMap 在进行扩容时的一个阈值，当 HashMap 中的元素个数超过了容量乘以负载因子时，就会进行扩容。<br>
默认的负载因子是 0.75，也就是说当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。当然，我们也可以通过构造函数来指定负载因子。<br>
HashMap默认初始容量是16，在第一次put时才初始化容量。<br>
官方说法：负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。<br>

#### 9、HashMap 底层实现？
HashMap 在不同的 JDK 版本下的实现是不同的，在 JDK 1.7 时，HashMap 底层是通过数组 + 链表实现的；而在 JDK 1.8 时，HashMap 底层是通过数组 + 链表或红黑树实现的。<br>
具体来说，HashMap 内部维护了一个数组，每个数组元素又是一个链表或者红黑树，每个链表或者红黑树节点存储了一个键值对。当需要存储新的键值对时，HashMap 会根据键的哈希值确定其在数组中的位置，如果该位置已经有了其他键值对，则通过链表或红黑树解决冲突，将新的键值对添加到链表或红黑树的末尾。<br>
在 JDK 1.8 之后，如果链表的数量大于阈值（默认为 8），并且数组长度大于 64 时，为了查询效率会将链表升级为红黑树，但当红黑树的节点小于等于 6 时，为了节省内存空间会将红黑树退化为链表。

#### 10、hashCode 计算时为啥喜欢用 31 作为乘数？
俩说法，一个是虚拟机会将 i * 31 优化成 (i << 5) - i ，避免了做乘法。另一个原因是采用 31, 33, 37, 39, 41 等数字，将使每次的哈希碰撞减少到7次以内。 

#### 11、HashMap 发生死循环？
HashMap 死循环发生在 JDK 1.8 之前的版本中，它是指在并发环境下，因为多个线程同时进行 put 操作，导致链表形成环形数据结构，一旦形成环形数据结构，在 get(key) 的时候就会产生死循环。<br>
主要原因：头插法、多线程并发操作、扩容操作（扩容后的单个链表内的内容顺序反转了，这是头插法引起的）<br>
直接看原链接：https://www.javacn.site/interview/basic/hashmap.html#%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A41

解决方案：<br>
升级到 JDK 1.8 以后，采用的尾插法。使用ConcurrentHashMap。其他保证线程安全的方式也可以，但是性能低不建议使用，如加锁或者换HashTable。

#### 12、哈希冲突的解决？
哈希冲突是指在哈希表中，两个或多个元素被映射到了同一个位置的情况。如 "3C" 和 "2b" 的 hashCode 都是 1648 <br>

在 Java 中，解决哈希冲突的常用方法有以下三种：链地址法、开放地址法和再哈希法。<br>
链地址法（Separate Chaining）：将哈希表中的每个桶都设置为一个链表，当发生哈希冲突时，将新的元素插入到链表的末尾。这种方法的优点是简单易懂，适用于元素数量较多的情况。缺点是当链表过长时，查询效率会降低。<br>
开放地址法（Open Addressing）：当发生哈希冲突时，通过一定的探测方法（如线性探测、二次探测、双重哈希等）在哈希表中寻找下一个可用的位置。这种方法的优点是不需要额外的存储空间，适用于元素数量较少的情况。缺点是容易产生聚集现象，即某些桶中的元素过多，而其他桶中的元素很少。<br>
再哈希法（Rehashing）：当发生哈希冲突时，使用另一个哈希函数计算出一个新的哈希值，然后将元素插入到对应的桶中。这种方法的优点是简单易懂，适用于元素数量较少的情况。缺点是需要额外的哈希函数，且当哈希函数不够随机时，容易产生聚集现象。

直接看原链接：https://www.javacn.site/interview/basic/hashmap-clash.html#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81

HashMap 是采用链地址法解决的。

#### 13、反射？
反射是在程序运行期间动态获取类和操纵类的一种技术。通过反射机制，可以在运行时动态地创建对象、调用方法、访问和修改属性，以及获取类的信息。<br>
使用场景：动态代理，依赖注入，数据库连接<br>
优点：灵活性，扩展性，实现更多功能。缺点：性能，安全（破坏封装，违反访问控制），兼容问题。<br>

底层实现原理：查找方法，安全检查，参数转换和适配，方法调用，异常处理（InvocationTargetException），返回结果

方法调用：对于非私有方法，Java 反射实际上是通过 JNI（Java Native Interface，Java 本地接口）调用到 JVM 内部的 native 方法，例如 java.lang.reflect.Method.invoke0()。这个 native 方法负责完成真正的动态方法调用。对于 Java 方法，JVM 会通过方法表、虚方法表（vtable）进行查找和调用；对于非虚方法或者静态方法，JVM 会直接调用相应的方法实现。

#### 14、链式调用？
User().setAge(12).setName("lilei"); 这是一种代码风格，可以实现简洁清晰的调用过程，其内部是每个方法都返回对象自身。

#### 15、Java 内存模型？


