看看这个哥们总结的：https://www.javacn.site/interview/basic/

#### 1、finally 中的代码一定会执行吗？
不一定。<br>
当try中有System.exit()方法时，程序会立即终止，finally中的代码将没有机会执行。<br>
当try中有Runtime.getRuntime().halt()方法时，程序也会立即终止，并且不会执行Hook方法和终结器。<br>
当try中有死循环或者死锁导致程序无法跳出try代码块时。<br>
非程序性的，例如 JVM崩溃了，或者停电了。<br>

#### 2、什么是 Hook 方法？
在编程中，钩子方法（Hook Method）是一种由父类提供的空或默认实现的方法，子类可以选择性地重写或扩展该方法，以实现特定的行为或定制化逻辑。<br>
钩子方法可以在父类中被调用，以提供一种可插拔的方式来影响父类的行为。钩子方法通常用于框架或模板方法设计模式中。框架提供一个骨架或模板，其中包含一些已经实现的方法及预留的钩子方法。<br>
具体的子类可以通过重写钩子方法来插入定制逻辑，从而影响父类方法的实现方式。

#### 3、ArrayList 和 LinkedList ？
都是List接口的实现类。<br>
底层实现：ArrayList是基于动态数组的数据结构；LinkedList是基于链表的数据结构。<br>
随机访问的性能不同：ArrayList 优于 LinkedList <br>
插入删除性能不同：LinkedList 优于 ArrayList <br>

#### 4、ArrayList 和 Vector ？
都是List接口的实现类，底层都是动态数组的实现。<br>
Vector是线程安全的，因此性能差于ArrayList。<br>
容量增长方式不同，ArrayList是增加一半（会频繁扩容）；而Vector是翻倍，所以后者适合大量数据的存储。

#### 5、为什么 ConcurrentHashMap 不能插入 null ？
HashMap 允许key和value都是null的。<br>
ConcurrentHashMap 都不允许。直接原因是源码中不支持插入null，会抛出空指针异常。深层原因是它的使用场景是多线程环境，也就是并发环境，如果允许null存在，就会出现二义性问题。<br>

二义性问题：<br>
所谓的二义性问题指的是代码或表达式存在多种理解或解释，导致程序的含义不明确或模糊。<br>
即null可以理解成“null”值，也可以理解成“没有”。HashMap是运行在单线程环境下，我们可以通过containsKey(null)来判断 “我们通过get()所得到” 的 null 是真实存在的null（null值），还是因为不存在这个key而返回的null（表示没有）。<br>
而ConcurrentHashMap却不能通过这样的方式（containsKey(null)）来判断，因为它运行在多线程环境中，当我们判断containsKey时，可能另一个线程此时存入了null值，所以没有办法保证解释清楚这个null的具体含义。<br>

#### 6、HashMap 和 HashTable ？
都是Map接口的实现类。前者不是线程安全的，后者是线程安全的。HashMap允许null的key和value，HashTable不允许null的key（因为要计算hash值，它没做特殊处理，HashMap做了特殊处理），也不允许null的value（原因也是二义性问题）。

#### 7、HashMap 和 HashSet ？
HashSet实现了Set接口，用于存储对象。HashMap实现了Map接口，用于存储键值对。<br>
HashSet底层是用HashMap实现的，将自己的值存储到HashMap的Key里面。<br>
HashSet不允许值重复。HashMap不允许键重复。

#### 8、HashMap 里的负载因子，为什么是 0.75 ？
HashMap 负载因子 loadFactor，也叫做扩容因子和装载因子，它是 HashMap 在进行扩容时的一个阈值，当 HashMap 中的元素个数超过了容量乘以负载因子时，就会进行扩容。<br>
默认的负载因子是 0.75，也就是说当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。当然，我们也可以通过构造函数来指定负载因子。<br>
HashMap默认初始容量是16，在第一次put时才初始化容量。<br>
官方说法：负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。<br>

#### 9、HashMap 底层实现？
HashMap 在不同的 JDK 版本下的实现是不同的，在 JDK 1.7 时，HashMap 底层是通过数组 + 链表实现的；而在 JDK 1.8 时，HashMap 底层是通过数组 + 链表或红黑树实现的。<br>
具体来说，HashMap 内部维护了一个数组，每个数组元素又是一个链表或者红黑树，每个链表或者红黑树节点存储了一个键值对。当需要存储新的键值对时，HashMap 会根据键的哈希值确定其在数组中的位置，如果该位置已经有了其他键值对，则通过链表或红黑树解决冲突，将新的键值对添加到链表或红黑树的末尾。<br>
在 JDK 1.8 之后，如果链表的数量大于阈值（默认为 8），并且数组长度大于 64 时，为了查询效率会将链表升级为红黑树，但当红黑树的节点小于等于 6 时，为了节省内存空间会将红黑树退化为链表。

#### 10、hashCode 计算时为啥喜欢用 31 作为乘数？
俩说法，一个是虚拟机会将 i * 31 优化成 (i << 5) - i ，避免了做乘法。另一个原因是采用 31, 33, 37, 39, 41 等数字，将使每次的哈希碰撞减少到7次以内。 

#### 11、HashMap 发生死循环？
HashMap 死循环发生在 JDK 1.8 之前的版本中，它是指在并发环境下，因为多个线程同时进行 put 操作，导致链表形成环形数据结构，一旦形成环形数据结构，在 get(key) 的时候就会产生死循环。<br>
主要原因：头插法、多线程并发操作、扩容操作（扩容后的单个链表内的内容顺序反转了，这是头插法引起的）<br>
直接看原链接：https://www.javacn.site/interview/basic/hashmap.html#%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A41

解决方案：<br>
升级到 JDK 1.8 以后，采用的尾插法。使用ConcurrentHashMap。其他保证线程安全的方式也可以，但是性能低不建议使用，如加锁或者换HashTable。

#### 12、哈希冲突的解决？
哈希冲突是指在哈希表中，两个或多个元素被映射到了同一个位置的情况。如 "3C" 和 "2b" 的 hashCode 都是 1648 <br>

在 Java 中，解决哈希冲突的常用方法有以下三种：链地址法、开放地址法和再哈希法。<br>
链地址法（Separate Chaining）：将哈希表中的每个桶都设置为一个链表，当发生哈希冲突时，将新的元素插入到链表的末尾。这种方法的优点是简单易懂，适用于元素数量较多的情况。缺点是当链表过长时，查询效率会降低。<br>
开放地址法（Open Addressing）：当发生哈希冲突时，通过一定的探测方法（如线性探测、二次探测、双重哈希等）在哈希表中寻找下一个可用的位置。这种方法的优点是不需要额外的存储空间，适用于元素数量较少的情况。缺点是容易产生聚集现象，即某些桶中的元素过多，而其他桶中的元素很少。<br>
再哈希法（Rehashing）：当发生哈希冲突时，使用另一个哈希函数计算出一个新的哈希值，然后将元素插入到对应的桶中。这种方法的优点是简单易懂，适用于元素数量较少的情况。缺点是需要额外的哈希函数，且当哈希函数不够随机时，容易产生聚集现象。

直接看原链接：https://www.javacn.site/interview/basic/hashmap-clash.html#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81

HashMap 是采用链地址法解决的。

#### 13、反射？
反射是在程序运行期间动态获取类和操纵类的一种技术。通过反射机制，可以在运行时动态地创建对象、调用方法、访问和修改属性，以及获取类的信息。<br>
使用场景：动态代理，依赖注入，数据库连接<br>
优点：灵活性，扩展性，实现更多功能。缺点：性能，安全（破坏封装，违反访问控制），兼容问题。<br>

底层实现原理：查找方法，安全检查，参数转换和适配，方法调用，异常处理（InvocationTargetException），返回结果

方法调用：对于非私有方法，Java 反射实际上是通过 JNI（Java Native Interface，Java 本地接口）调用到 JVM 内部的 native 方法，例如 java.lang.reflect.Method.invoke0()。这个 native 方法负责完成真正的动态方法调用。对于 Java 方法，JVM 会通过方法表、虚方法表（vtable）进行查找和调用；对于非虚方法或者静态方法，JVM 会直接调用相应的方法实现。

#### 14、链式调用？
User().setAge(12).setName("lilei"); 这是一种代码风格，可以实现简洁清晰的调用过程，其内部是每个方法都返回对象自身。

#### 15、Java 内存模型 JMM ？
当问到 Java 内存模型的时候，一定要注意，Java 内存模型（Java Memory Model，JMM）它和 JVM 内存布局（JVM 运行时数据区域）是不一样的，它们是两个完全不同的概念。<br>
Java 内存模型存在的原因在于解决多线程环境下并发执行时的内存可见性和一致性问题。在现代计算机系统中，尤其是多处理器架构下，每个处理器都有自己的高速缓存，而主内存（RAM）是所有处理器共享的数据存储区域。<br>
当多个线程同时访问和修改同一块共享数据时，如果没有适当的同步机制，就可能导致以下问题：<br>
* 可见性：一个线程对共享变量所做的修改可能不会立即反映到另一个线程的视角中，因为这些修改可能只存在于本地缓存中，并未刷新回主内存。
* 有序性：编译器和处理器为了优化性能，可能会对指令进行重排序，这可能导致程序在单线程环境中看似按照源代码顺序执行，但在多线程环境中的实际执行顺序却与预期不同。
* 原子性：即使是最简单的读取或赋值操作，在硬件层面也不一定保证是原子性的，即在没有同步的情况下，多线程下可能看到操作只执行了一部分的结果。
Java 内存模型通过定义一套规则来规范并限制编译器、运行时以及处理器对内存访问的重排序行为，确保了多线程间的交互具有明确的语义。<br>
它规定了共享变量的访问规则、提供了 happens-before 原则以及 volatile 关键字、synchronized 等工具来实现内存可见性和一致性的保障。这样，程序员在编写并发代码时，可以依据这些规则来确保代码的正确执行，从而避免由于多线程带来的不确定性和错误。

主内存（各线程共享）、工作内存（线程自己的）、内存间交互操作（线程去读\写主内存）、原子性、可见性、有序性。开发者可以利用 JMM 提供的同步机制（如关键字 volatile、synchronized、Lock 等）来实现线程之间的同步和通信，以确保线程安全和数据一致性。

交互规范（了解即可）：<br>
工作内存 store -> write 主内存（把值刷回主内存）
主内存 read -> load 工作内存（从主内存加载值）
执行引擎（计算结束存值） -> assign 工作内存
工作内存 -> use 执行引擎（从工作内存读取值）
主内存 lock\unlock （标记主内存的变量是否被某一个线程独占）

直接看原链接：https://www.javacn.site/interview/basic/jmm.html#_3-%E8%A7%84%E8%8C%83%E5%86%85%E5%AE%B9

#### 16、零拷贝？
用户态、内核态。传统的IO操作，都需要从硬盘到内核（CPU）再到用户（内存）的两次拷贝。DMA（Direct Memory Access，直接内存访问）技术，绕过 CPU，直接在内存和外设之间进行数据传输。这样可以减少 CPU 的参与，提高数据传输的效率。<br>
零拷贝技术可以利用 Linux 下的 MMap、sendFile 等手段来实现，使得数据能够直接从磁盘映射到内核缓冲区，然后通过 DMA 传输到网卡缓存，整个过程中 CPU 只负责管理和调度，而无需执行实际的数据复制指令。<br>
MMap（Memory Map）是 Linux 操作系统中提供的一种将文件映射到进程地址空间的一种机制，通过 MMap 进程可以像访问内存一样访问文件，而无需显式的复制操作。<br>

#### 17、ThreadLocal ？
底层是 通过让 Thread 持有唯一的一个 ThreadLocalMap 实现的，当通过某个 ThreadLocal 存值或者取值时，ThreadLocal 会从 Thread 中取出 ThreadLocalMap（如果没有初始化，就创建一个 ThreadLocalMap 对象 并赋值给 Thread 对象 持有），然后以当前 ThreadLocal 为 key 进行存取。<br>
存在的问题：<br>
* 性能问题：ThreadLocalMap 类似于哈希表。当一个线程是拥有多个 ThreadLocal 时，ThreadLocalMap 很容易发生 Hash 冲突，此时 ThreadLocal 就不得不使用线性探测法来解决哈希冲突了，而在解决 Hash 冲突时需要不停地向下寻找，效率较低，因此 ThreadLocal 存在的第一个问题就是性能较低。
* 内存泄漏：ThreadLocalMap 中Key是弱引用，Value是强引用，导致键也无法被回收。Map 对 Entry 的强引用，导致 Entry 中的对象无法被回收。线程存活周期长，Entry 长期不被清理，造成内存泄漏。解决办法是使用完后，及时调用remove()。

FastThreadLocal：使用数组进行存储，不存在哈希冲突问题。如果数组下标递增到非常大，那么数组也会比较大，所以 FastThreadLocal 是通过空间换时间的思想提升读写性能。它还提供了FastThreadLocalRunnable用于在run方法执行完后，自动清理自己，避免内存泄漏。

#### 18、Java 是值传递还是引用传递？
* 值传递（Pass by Value）：在值传递中，实际参数的值被复制一份，然后将这份复制的值传递给函数或方法的相应参数。因此，函数或方法内对参数所做的任何修改都不会影响到实际参数的值。
* 引用传递（Pass by Reference）：在引用传递中，传递给方法的是实际参数的引用（或地址）。这意味着方法内对参数所做的任何修改都会直接影响到实际参数。

需要注意的是，有些编程语言，如 C++ 提供了真正的引用传递机制，允许你直接传递变量的引用，并且可以在函数或方法中改变这个引用的指向。而在 Java 中，即使是对象，也是通过值传递的，只不过这个值是对象引用副本（而非对象引用本身）。

当传递基本数据类型，比如原始类型（int、long、char等）、包装类型（Integer、Long、Character等），实参和形参都是存储在不同的栈帧内，修改形参的栈帧数据，不会影响实参的数据。<br>
当传递引用类型，形参和实参指向同一个地址的时候，修改形参地址的内容，会影响到实参。当形参和实参指向不同的地址的时候，修改形参地址的内容，并不会影响到实参。<br>

看看这里：https://www.51cto.com/article/721878.html

#### 19、Lambda表达式实现原理？
注解 @FunctionalInterface 用于标记一个接口是否为函数式接口，即只包含一个抽象方法的接口。函数式接口的出现是为了实现lambda表达式，lambda表达式通过对唯一抽象方法的识别，来推断参数类型和返回值类型。<br>
它是匿名内部类的语法糖，实际在运行时依然会生成匿名内部类。
